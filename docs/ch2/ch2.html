---
layout: default
---

<!DOCTYPE html>
<html>
  <head>
    <title>Клиент-серверные многозвенные архитектуры</title>
  </head>
  <body>
    <h1>Клиент/Сервер и многозвенные архитектурные шаблоны</h1>
    <p>
      В этом разделе приведен высокоуровневый обзор архитектурных шаблонов
      клиент-сервер. Мы начинаем с двухуровневых моделей клиент-сервер и увидим
      как ограничения двухуровневых моделей клиент-сервер привели к разработке
      трехуровневых и затем n-уровневых моделей клиент-сервер. Также кратко
      рассмотрим такие вариации клиент-серверной модели как master-slave,
      peer-to-peer с примерами использования. Завтем мы рассмотрим типовые
      фреймворки веб-приложений. Требования к веб-приложениям отличаются от
      требований к классическим клиент-серверным приложениям, и ключевым
      отличительным фактором является динамическое обновление пользовательского
      интерфейса на основе изменений в базе данных. Мы постараемся рассмотреть
      наиболее популярные шаблоны, используемые при разработке веб-приложений
    </p>
    <p>Основные темы этой части</p>
    <div>
      <ul>
        <li>2-звенные, 3-звенные и n-звенные шаблоны</li>
        <li>шаблон master-slave</li>
        <li>шаблон per-to-peer</li>
        <li>распределенная клиент-серверная модель</li>
        <li>шаблон model-view-controller</li>
        <li>шаблон model-view-presenter</li>
        <li>шаблон model-view-model</li>
        <li>шаблон front controller</li>
        <li>типовые шаблоны веб-приложений</li>
      </ul>
    </div>
    <p>
      Модель клиент сервер это один из старейших архитектурных шаблонов. Он
      описывает коммуникацию двух разных частей, клиентской и серверной
    </p>
    <ul>
      <li>
        Клиент: инициатор соединения, является потребителем услуг которые
        предоставляет сервис в ответ на запросы клиента
      </li>
      <li>
        Сервер: компонент, который является поставщиком услуг и предоставляет
        услуги клиенту в соответствии с поступающими от клиента запросами
      </li>
    </ul>
    <p>
      Клиент и сервер обычно составляют распределенную систему и взаимодействуют
      используя коммуникационную сеть
    </p>
    <p></p>
    <p>
      Не существует принципиального ограничения количества клиентов, которые
      могут обслуживаться одним сервером. Также не обязательно, чтобы клиент и
      сервер находились в разных системах. Связь между клиентом и сервером
      осуществляется путем обмена сообщениями по схеме "запрос-ответ". Клиент
      отправляет запрос на обслуживание, а сервер возвращает ответ. Эта схема
      взаимодействия "запрос-ответ" является примером межпроцессного
      взаимодействия. Для эффективного взаимодействия необходимо иметь четко
      определенный протокол связи, устанавливающий правила взаимодействия, такие
      как формат сообщений, правила обработки ошибок и так далее. Все
      коммуникационные протоколы, используемые для взаимодействия клиент-сервер,
      работают на прикладном уровне стека протоколов. Для дальнейшей оптимизации
      в процессе взаимодействия клиент-сервер сервер иногда реализует
      специальные интерфейсы прикладного программирования (API), которые могут
      быть использованы клиентом для доступа к какой-либо конкретной услуге с
      сервера. Шаблон клиент-сервер, изображенный на рисунке, имеет два уровня:
      клиентский и серверный, и поэтому его также называют двухуровневым
      шаблоном или двухуровневой системой клиент-сервер
    </p>
    <img src="./media/01_client_server.png" />
    <p>
      Термин "сервис", используемый в контексте клиент-серверной архитектуры,
      относится к абстракции ресурса. Ресурс может быть любого типа, а имя
      сервера определяется на основе ресурса, который предоставляется сервером
      (сервис). Например, если сервер предоставляет веб -страницы, он называется
      веб-сервером, а если сервер предоставляет файлы, он называется файловым
      сервером и т.д. Сервер может получать запросы от множества клиентов в
      любой момент времени. Но любой физический сервер имеет ограничения
      возможностей обработки потока сообщений. Поэтому часто сервер должен
      определять приоритет входящих запросов и обслуживать их в соответствии с
      их приоритетом. Система планирования, используемая на сервере, помогает
      серверу в распределении приоритетов. Ниже приведены общие области
      применения шаблонов клиент-сервер для различных случаев использования.
    </p>
    <p>
      Email сервер и email коиент: Сервер отправляет письма в ответ на запрос с
      клиента. Примеры - Microsoft Exchange от Microsoft, Gmail от Google И
      другие. Работу такой почтовой системы можно описать так:
    </p>
    <img src="./media/02_mail_system.png" />
    <p>
      Когда вы отправляете письмо, приложение почтового клиента связывается с
      почтовым сервером по протоколу SMTP и загружает содержимое на сервер.
      Когда оно загружено, почтовая система доставляет письмо на другой сервер,
      который использует протокол POP3 для обслуживания клиентского ПО
      доставляющего письмо адресату. Подробное описание этого процесса это не
      тема этого документа, но если тема заинтересовала - можно почитать
      <a href="https://emailsoldiers.ru/glossary/email-protocol">статью</a>.
    </p>
    <h2>Сервер доменных имен (DNS) и DNS-клиент</h2>
    <p>
      DNS - одна из самых важных служб, существующих в Интернете. В Интернете
      есть огромное количество устройств, и каждое из этих устройств называется
      хостом. Каждый хост может быть принтером, маршрутизатором, компьютером или
      любым другим устройством. Каждый хост имеет уникальный адрес, называемый
      IP-адресом. Помимо IP-адреса, с каждым хостом также связано уникальное имя
      хоста. Например, если имя хоста равно LP231 и он присутствует в домене
      acme.com, то полное доменное имя (FQDN) хоста равно LP231.acme.com. Полное
      доменное имя используется для уникальной идентификации хоста в
      пространстве имен DNS. Пространство имен DNS содержит несколько часто
      используемых суффиксов имен, например:
    </p>
    <ul>
      <li>.com: коммерческие организации</li>
      <li>.org: некоммерческие организации</li>
      <li>.edu: учебные учреждения</li>
    </ul>
    <h2>Работа системы DNS</h2>
    <p>
      Система DNS работает с использованием концепции распределенных баз данных,
      основанной на модели клиент-сервер. DNS-клиенты - это объекты, которым
      требуется разрешение имен (сопоставление имен хостов с IP -адресами).
      DNS-серверы поддерживают данные, необходимые для разрешения имен.
      Высокоуровневая схема архитектуры DNS клиент-сервер приведена на следующей
      диаграмме:
    </p>
    <img src="./media/03_dns_system.png" />
    <p>
      Предположим, что URL-адрес www.acme.com введен в браузере DNS-клиента.
      Браузер подключается к DNS-серверу, чтобы получить IP-адрес
      соответствующий доменному имени. DNS-сервер выполняет эту задачу, сначала
      подключаясь к одному из корневых (root) DNS-серверов. Корневые серверы
      хранят IP-адреса всех DNS-серверов, которые обрабатывают домены верхнего
      уровня, такие как .edu, .com и так далее. В этом примере корневой сервер,
      получив IP-адрес домена верхнего уровня .com отправляет в ответ адрес TLD
      DNS сервера, который обрабатывает адреса домена acme.com. Этот сервер, в
      свою очередь, возвращает полный полный IP-адрес, который отпраялется
      обратно клиенту, который инициировал запрос DNS. Затем компьютер-клиент
      DNS может использовать IP-адрес для доступа к требуемой веб-странице.
      Подробнее о процессе можно почитать
      <a href="https://blog.skillfactory.ru/glossary/dns/">здесь</a>.
    </p>
    <p>Основными аспектами этой клиент-серверной архитектуры являются:</p>
    <ul>
      <li>
        <b>Избыточность (Redundancy):</b> На каждом уровне имеется несколько
        DNS-серверов, так что даже в случае сбоя одного из них другой сервер
        может взять на себя его роль.
      </li>
      <li>
        <b>Кэширование:</b>Как только DNS-запрос разрешен, DNS-сервер кэширует
        полученный им IP-адрес. Например, когда IP-адрес сервера домена .com
        кэшируется DNS-сервером, любые последующие запросы к домену .com
        обрабатываются без запуска механизмов повторяющихся запросов DNS
      </li>
    </ul>
    <h2>
      Функциональные требования в шаблонах двухуровневых моделей клиент-сервер
    </h2>
    
        <table>
            <thead>
                <tr>
                    <th>
                        <div>
                            <div>Функцилнальная роль</div>
                        </div>
                    </th>
                    <th>Описание</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Службы представления</td>
                    <td>
                        <div>
                            <div>Обеспечивает пользовательский интерфейс и диалоговое управление</div>
                        </div>
                    </td>
                </tr>
                <tr>
                    <td>Службы логики представления</td>
                    <td>
                        <div>
                            <div>Взаимодействие с пользователем и проверка правильности вводимых данных</div>
                        </div>
                    </td>
                </tr>
                <tr>
                    <td>Бизнес-логика</td>
                    <td>
                        <div>Набор бизнес-правил, определяющих, как можно хранить,</div>
                        <div>создавать и изменять данные</div>
                    </td>
                </tr>
                <tr>
                    <td>Логика распространения</td>
                    <td>Управление коммуникациями</td>
                </tr>
                <tr>
                    <td>Логика СУБД</td>
                    <td>Операции с данными и управление целостностью данных</td>
                </tr>
                <tr>
                    <td>Службы СУБД</td>
                    <td>Управление различными атрибутами транзакций базы данных</td>
                </tr>
                <tr>
                    <td>Файловые службы</td>
                    <td>Операции с файлами и общий доступ к файлам</td>
                </tr>
            </tbody>
        </table>
        </div>
    <h2>Распределение функциональных ролей в схеме клиент сервер</h2>    
    <p>В самом широком смысле системы клиент сервер делятся на:</p>
    <ul>
        <li><b>Схемы с "толстым" клиентом:</b> Большинство функциональных служб выполняются клиентским компонентом. Классическим примером толстого клиента является файловый сервер</li>
        <li><b>Схемы с "тонким" клиентом:</b> Большинство функциональных служб выполняются серверным компонентом (и он же берет на себя вычислительную нагрузку)</li>
    </ul>
    <p>Выбор клиента производится в зависимости от типа схемы клиент-сервер, которая запланирована в системе. Например, если схема предусматривает выполнение большого количества функций
        на стороне клиента, то имеет смысл перенести все на сторону клиента, и наоборот.  Функциональные требования, которые обсуждаются в этом разделе, дадут более полное представление о
        выборе клиентских и серверных подходов для реализации конкретных шаблонов взаимодействия клиент-сервер.</p>
    <p>Существуют различные способы реализации функционала в шаблоне клиент-сервер. Ниже приведены некоторые из наиболее распространенных способов:</p>
    <ul>
        <li>шаблон remote data access</li>
        <li>шаблон remote presentation</li>
        <li>шаблон split logic</li>
    </ul>
    <h2>Шаблон remote data access</h2>
    <p>В схеме remote data access приложение находится в клиентском компоненте, в то время как управление данными осуществляется серверным компонентом. Сервер, который выполняет управление данными, обычно называется сервером системы управления базами данных
         (СУБД) или сервером данных. СУБД продукты обычно предоставляют уровень или компонент программного обеспечения на стороне клиента, который
         управляет взаимодействием с сервером данных. Этот компонент программного обеспечения предоставляет средство data manipulation language (DML). 
         Клиентские системы поддерживают представление и бизнес-логику и взаимодействуют с сервером данных с помощью DML. Эти модели обычно предполагают использование толстого клиента, поскольку значительный объем обработки также выполняется клиентскими системами.
         Распределение функционала в архитектуре remote data access показана на следующей диаграмме:</p>
         <img src="./media/04_remote_data.png" />
         <h2>Шаблон remote presentation</h2>
         <p>В схеме remote presentation интерфейс пользователя (GUI) сопоставляется с экранной формой существующего приложения при помощи текстового представления. 
            Типичный режим работы этого шаблона предполагает использование рабочих станций, которые оснащены возможностью перехватывать текстовые
            потоки данных, отправляемые с серверной системы, и отображать их на экране. В этих системах обработка и вычисления происходят только на стороне сервера. 
            По похожей схеме работает обычный браузер, но наличие возможности скриптовой обработки отличает эту схему от remote presentation. Одним из идеальных примеров такой реализации является IBM 3270 (мэйнфрейм). 
            В этой схеме данные формируются на мейнфрейме. Затем данные отправляются на клиентскую рабочую станцию в виде потока данных размером 3270 пикселей. Клиентская рабочая станция получает данные, интерпретирует их и преобразует
            в графическую форму для отображения в окне. Если пользователь вводит какие-либо данные через клиентскую рабочую станцию в окне графического интерфейса пользователя, то приложение front ware, которое запускается на клиенте
             рабочая станция преобразует данные в формат, совместимый с 3270, и отправляет их обратно на сервер для выполнения дальнейших действий. Разделение функций в схеме клиент-сервер удаленной презентации
            показано на следующей диаграмме:</p> 
            <img src="./media/05_remote_presentation.png" />    
        <h2></h2>
        <p>В модели split logic функциональность приложения разделена на две части: одна будет реализована на стороне клиента, а другая на стороне сервера. Этот шаблон является очень сложным по сравнению с
            двумя другими шаблонами, поскольку для его функционирования и клиенту, и серверу требуются отдельно скомпилированные прикладные программы. Перед внедрением этого шаблона разработчикам очень важно
            определить функции, которые должны быть реализованы на стороне клиента и сервера, и составить список необходимых функций и экранных форм, которые должны выполняться на стороне клиента и сервера. Такая схема показана на следующей диаграмме:</p>
            <img src="./media/06_split_logic.png" />            
        <h1>Трех- и Многозвенные шаблоны клиент-серверной модели</h1>
        <P>Рассмотрим еще несколько вариаций клиент-серверной модели. Вот еще два типовых случая:</P>
        <ul>
            <li>шаблон master-slave </li>
            <li>шаблон peer-to-peer</li>
        </ul>
        <p>Рассмотрим их подробнее</p>    
        <h2>Master-slave</h2>
        <p>Шаблон master-slave применяется при проектировании системы, если система включает в себя аналогичные или похожие вычисления, которые необходимо выполнять повторно с разными наборами входных данных и
            контекстом. Шаблон master-slave обеспечивает отказоустойчивость и параллельные вычисления.</p>
        <p>Главный компонент распределяет работу между всеми подчиненными компонентами и вычисляет конечный результат, суммируя результаты, которые возвращает каждый подчиненный компонент. Шаблон master-slave
            используется для проектирования встраиваемых систем и используется при проектировании систем, которые выполняют массовые параллельные вычисления. Ниже приведена схема последовательности
            действий шаблона master slave:</p>
        <img src="./media/07_master_slave.png" />
        <h2>Возможные применения шаблона master-slave</h2>   
        <p>Схема "главный-подчиненный" работает по принципу "разделяй и властвуй". При использовании этой схемы концепция координации отделена от реальной работы, поскольку все подчиненные
            устройства работают параллельно. Следовательно, у подчиненных устройств нет общего состояния, они работают изолированно. Проблемой в шаблоне master slave является потенциальная задержка. 
            Это может вызвать проблему в системах, где время отклика очень важно. Этот может быть применен к конкретной проблеме, только если она поддается декомпозиции.</p>
        <p>Один из способов реализации шаблона master-slave заключается в использовании одного главного потока, который создает несколько подчиненных потоков. Каждый из подчиненных потоков выполняет часть
            общего вычисления и возвращает результат главному потоку. Как только вычисление завершено, главный поток объединяет результаты и завершает работу подчиненных потоков.</p>
        <h2>Peer-to-peer</h2>    
        <p>Peer-to-peer архитектурные шаблоны относятся к категории симметричных клиент-серверных
            шаблонов. Симметричность в данном контексте означает, что одна и та же система может выполнять функции клиента и сервера. Такая система, также называемая одноранговой, отправляет запросы
            другим одноранговым узлам в сети и в то же время получает и обслуживает запросы от других одноранговых узлов. </p>
        <p>Этот шаблон обычно используется для реализации децентрализованной сети узлов, использующих распределенные ресурсы. Распределенными
            ресурсами могут быть либо вычислительные мощности, либо данные, которые могут использоваться для задач распределенных вычислений, 
            таких как совместное использование контента, коммуникация и так далее. Общий шаблон одноранговоой системы показан на следующей диаграмме (однако возможны некоторые
            вариации):</p>
        <img src="./media/08_peer_2_peer.png" />
        <p>Есть два самых распространенных варианта реализации такого шаблона:</p>
        <ul>
            <li><B>pure peer-to_peer:</B> сервер используется только как промежуточное звено связи клиентов, не имеет никакой логики и никак не влияет на работу системы в уцелом. Примером такой реализации является протокол обмена файлами Gnutella</li>
            <li><B>гибридная peer-to_peer:</B> сервер выполняет некоторые административные функции, помогая работе клиентов. Примером такой реализации является протокол Napster</li>
        </ul>
        <p>Хотя схемы peer-to-peer очень эффективны для таких приложений, как общий доступ к файлам, они также
            предоставляют возможности для реализации множества угроз безопасности. TCP-порты, используемые одноранговыми приложениями, должны постоянно контролироваться 
            и находиться под наблюдением систем предотвращения вторжений.</p>
        <h2>Преимущества двухуровневых клиент-серверных схем</h2>
        <p>Некоторые ключевые преимуществ клиент серверных систем:</p>
        <ul>
            <li>Безопасность: Данные хранятся централизованно на сервере. Это обеспечивает больший контроль и более высокий уровень безопасности, чем защита данных, которые будут
                распределены по большому количеству клиентских компьютеров.</li>
            <li>Централизованный доступ к данным: Поскольку большая часть данных хранится централизованно на сервере,
                обновлять данные и поддерживать их согласованность намного проще. Это один из самых простых архитектурных стилей.</li>
            <li>Простота обслуживания: При такой архитектурной схеме клиент не осведомлен о деталях работы сервера, и, следовательно, действия по обслуживанию сервера мало влияют на работу клиента</li>
        </ul>
        <h2>Конструктивные соображения - когда следует использовать двухуровневую схему клиент-сервер?</h2>
        <p>После того, как мы подробно рассмотрели шаблоны клиент-сервер, возникает следующий вопрос: когда следует использовать двухуровневую схему клиент-сервер для конкретного архитектурного
            проекта. Следующие моменты могут быть использованы в качестве ориентира при принятии решения:</p>
        <ul>
            <li>Если рассматриваемое приложение имеет централизованную логику и будет поддерживать множество
                клиентов, то хорошим выбором будет двухуровневый шаблон клиент-сервер.</li>
            <li>По этой схеме часто организованы приложения которые будут использоваться внутри одной организации как рабочие места с общим центром управления</li>
            <li>Если вы хотите централизовать операции с данными, такие как хранение, резервное копирование и другие
                связанные с этим задачи администрирования, то двухуровневая структура клиент-сервер является идеальным выбором.</li>
        </ul>
        <h2>Ограничения двузвенной архитектуры</h2>
        <p>Вот главные ограничения таких систем:</p>
        <ul>
            <li>Ограниченная расширяемость и масштабируемость: В большинстве
                реализаций данные приложения и бизнес-логика хранятся на одном центральном
                сервере. Этот аспект влияет на расширяемость и масштабируемость системы, так как она ограничена мощностью центрального узла (только вертикальное масштабирование)</li>
            <li>Интенсивное использование полосы пропускания сети: при обмене данными между клиентом и
                сервером передается много данных. Данные запросов и ответов часто необходимо
                преобразовывать в общий формат, это также способствует
                увеличению трафика.</li>
        </ul>
        <p>Чтобы преодолеть эти ограничения двухуровневой модели клиент-сервер, была разработана трехуровневая/многоуровневая
            архитектура клиент-сервер. Большинство современных приложений
            , разрабатываемых с использованием архитектуры клиент-сервер, основаны на трехуровневой
            архитектурной модели</p>
        <h2>Трехуровневая архитектура</h2>
        <p>В этой архитектуре присутствуют следующие три уровня (слоя):</p>
        <ul>
            <li><b>Презентационный слой:</b> Этот уровень предоставляет услуги презентации, то есть представление
                контента конечному пользователю через графический интерфейс. Доступ к этому уровню возможен с любого
                клиентского устройства, такого как настольный компьютер, ноутбук, планшет, мобильный телефон, тонкий клиент и так далее.</li>
            <li><b>Слой бизнес логики:</b>Это уровень, на
                котором выполняется бизнес-логика приложения. Компоненты этого уровня обычно выполняются на одном или нескольких
                серверах приложений</li>
            <li><b>Слой данных:</b> Данные приложения обычно хранятся на сервере базы данных, файловом сервере или любом другом устройстве или носителе, который поддерживает
                логику доступа к данным и обеспечивает необходимые действия для обеспечения доступа только к данным без предоставления какого-либо 
                доступа к механизмам хранения и извлечения данных. Это делается на уровне данных путем предоставления API для уровня бизнес-логики. Предоставление этого API обеспечивает полную прозрачность данных
                 операции, выполняемые на этом уровне, не влияют на уровень приложений. Например, обновления систем на этом уровне не влияют на уровень приложений в данной архитектуре.</li>
        </ul>
        <p>Преимсущества:</p>
        <ul>
            <li><b>Масштабируемость и гибкость: </b> Основным преимуществом этой архитектуры является ее
                масштабируемость и гибкость. Каждый уровень этой архитектуры является модульным компонентом,
                то есть любые операции, такие как изменения или обновления, выполняемые на одном уровне, не
                влияют на другие уровни и не вызывают простоев. 
                Клиентские системы на уровне представления, обладают меньшей функциональностью и не требуют сложной конфигурации.</li>
            <li><b>Дополнительная безопасность: </b>Распределение задач по различным уровням обеспечивает повышенную
                безопасность каждого уровня.</li>
        </ul>
  </body>
</html>
