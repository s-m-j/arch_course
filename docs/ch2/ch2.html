---
layout: default
---

<!DOCTYPE html>
<html>
  <head>
    <title>Клиент-серверные многозвенные архитектуры</title>
  </head>
  <body>
    <h1>Клиент/Сервер и многозвенные архитектурные шаблоны</h1>
    <p>
      В этом разделе приведен высокоуровневый обзор архитектурных шаблонов
      клиент-сервер. Мы начинаем с двухуровневых моделей клиент-сервер и увидим
      как ограничения двухуровневых моделей клиент-сервер привели к разработке
      трехуровневых и затем n-уровневых моделей клиент-сервер. Также кратко
      рассмотрим такие вариации клиент-серверной модели как master-slave,
      peer-to-peer с примерами использования. Завтем мы рассмотрим типовые
      фреймворки веб-приложений. Требования к веб-приложениям отличаются от
      требований к классическим клиент-серверным приложениям, и ключевым
      отличительным фактором является динамическое обновление пользовательского
      интерфейса на основе изменений в базе данных. Мы постараемся рассмотреть
      наиболее популярные шаблоны, используемые при разработке веб-приложений
    </p>
    <p>Основные темы этой части</p>
    <div>
      <ul>
        <li>2-звенные, 3-звенные и n-звенные шаблоны</li>
        <li>шаблон master-slave</li>
        <li>шаблон per-to-peer</li>
        <li>распределенная клиент-серверная модель</li>
        <li>шаблон model-view-controller</li>
        <li>шаблон model-view-presenter</li>
        <li>шаблон model-view-model</li>
        <li>шаблон front controller</li>
        <li>типовые шаблоны веб-приложений</li>
      </ul>
    </div>
    <p>
      Модель клиент сервер это один из старейших архитектурных шаблонов. Он
      описывает коммуникацию двух разных частей, клиентской и серверной
    </p>
    <ul>
      <li>
        Клиент: инициатор соединения, является потребителем услуг которые
        предоставляет сервис в ответ на запросы клиента
      </li>
      <li>
        Сервер: компонент, который является поставщиком услуг и предоставляет
        услуги клиенту в соответствии с поступающими от клиента запросами
      </li>
    </ul>
    <p>
      Клиент и сервер обычно составляют распределенную систему и взаимодействуют
      используя коммуникационную сеть
    </p>
    <p></p>
    <p>
      Не существует принципиального ограничения количества клиентов, которые
      могут обслуживаться одним сервером. Также не обязательно, чтобы клиент и
      сервер находились в разных системах. Связь между клиентом и сервером
      осуществляется путем обмена сообщениями по схеме "запрос-ответ". Клиент
      отправляет запрос на обслуживание, а сервер возвращает ответ. Эта схема
      взаимодействия "запрос-ответ" является примером межпроцессного
      взаимодействия. Для эффективного взаимодействия необходимо иметь четко
      определенный протокол связи, устанавливающий правила взаимодействия, такие
      как формат сообщений, правила обработки ошибок и так далее. Все
      коммуникационные протоколы, используемые для взаимодействия клиент-сервер,
      работают на прикладном уровне стека протоколов. Для дальнейшей оптимизации
      в процессе взаимодействия клиент-сервер сервер иногда реализует
      специальные интерфейсы прикладного программирования (API), которые могут
      быть использованы клиентом для доступа к какой-либо конкретной услуге с
      сервера. Шаблон клиент-сервер, изображенный на рисунке, имеет два уровня:
      клиентский и серверный, и поэтому его также называют двухуровневым
      шаблоном или двухуровневой системой клиент-сервер
    </p>
    <img src="./media/01_client_server.png" />
    <p>
      Термин "сервис", используемый в контексте клиент-серверной архитектуры,
      относится к абстракции ресурса. Ресурс может быть любого типа, а имя
      сервера определяется на основе ресурса, который предоставляется сервером
      (сервис). Например, если сервер предоставляет веб -страницы, он называется
      веб-сервером, а если сервер предоставляет файлы, он называется файловым
      сервером и т.д. Сервер может получать запросы от множества клиентов в
      любой момент времени. Но любой физический сервер имеет ограничения
      возможностей обработки потока сообщений. Поэтому часто сервер должен
      определять приоритет входящих запросов и обслуживать их в соответствии с
      их приоритетом. Система планирования, используемая на сервере, помогает
      серверу в распределении приоритетов. Ниже приведены общие области
      применения шаблонов клиент-сервер для различных случаев использования.
    </p>
    <p>
      Email сервер и email коиент: Сервер отправляет письма в ответ на запрос с
      клиента. Примеры - Microsoft Exchange от Microsoft, Gmail от Google И
      другие. Работу такой почтовой системы можно описать так:
    </p>
    <img src="./media/02_mail_system.png" />
    <p>
      Когда вы отправляете письмо, приложение почтового клиента связывается с
      почтовым сервером по протоколу SMTP и загружает содержимое на сервер.
      Когда оно загружено, почтовая система доставляет письмо на другой сервер,
      который использует протокол POP3 для обслуживания клиентского ПО
      доставляющего письмо адресату. Подробное описание этого процесса это не
      тема этого документа, но если тема заинтересовала - можно почитать
      <a href="https://emailsoldiers.ru/glossary/email-protocol">статью</a>.
    </p>
    <h2>Сервер доменных имен (DNS) и DNS-клиент</h2>
    <p>
      DNS - одна из самых важных служб, существующих в Интернете. В Интернете
      есть огромное количество устройств, и каждое из этих устройств называется
      хостом. Каждый хост может быть принтером, маршрутизатором, компьютером или
      любым другим устройством. Каждый хост имеет уникальный адрес, называемый
      IP-адресом. Помимо IP-адреса, с каждым хостом также связано уникальное имя
      хоста. Например, если имя хоста равно LP231 и он присутствует в домене
      acme.com, то полное доменное имя (FQDN) хоста равно LP231.acme.com. Полное
      доменное имя используется для уникальной идентификации хоста в
      пространстве имен DNS. Пространство имен DNS содержит несколько часто
      используемых суффиксов имен, например:
    </p>
    <ul>
      <li>.com: коммерческие организации</li>
      <li>.org: некоммерческие организации</li>
      <li>.edu: учебные учреждения</li>
    </ul>
    <h2>Работа системы DNS</h2>
    <p>
      Система DNS работает с использованием концепции распределенных баз данных,
      основанной на модели клиент-сервер. DNS-клиенты - это объекты, которым
      требуется разрешение имен (сопоставление имен хостов с IP -адресами).
      DNS-серверы поддерживают данные, необходимые для разрешения имен.
      Высокоуровневая схема архитектуры DNS клиент-сервер приведена на следующей
      диаграмме:
    </p>
    <img src="./media/03_dns_system.png" />
    <p>
      Предположим, что URL-адрес www.acme.com введен в браузере DNS-клиента.
      Браузер подключается к DNS-серверу, чтобы получить IP-адрес
      соответствующий доменному имени. DNS-сервер выполняет эту задачу, сначала
      подключаясь к одному из корневых (root) DNS-серверов. Корневые серверы
      хранят IP-адреса всех DNS-серверов, которые обрабатывают домены верхнего
      уровня, такие как .edu, .com и так далее. В этом примере корневой сервер,
      получив IP-адрес домена верхнего уровня .com отправляет в ответ адрес TLD
      DNS сервера, который обрабатывает адреса домена acme.com. Этот сервер, в
      свою очередь, возвращает полный полный IP-адрес, который отпраялется
      обратно клиенту, который инициировал запрос DNS. Затем компьютер-клиент
      DNS может использовать IP-адрес для доступа к требуемой веб-странице.
      Подробнее о процессе можно почитать
      <a href="https://blog.skillfactory.ru/glossary/dns/">здесь</a>.
    </p>
    <p>Основными аспектами этой клиент-серверной архитектуры являются:</p>
    <ul>
      <li>
        <b>Избыточность (Redundancy):</b> На каждом уровне имеется несколько
        DNS-серверов, так что даже в случае сбоя одного из них другой сервер
        может взять на себя его роль.
      </li>
      <li>
        <b>Кэширование:</b>Как только DNS-запрос разрешен, DNS-сервер кэширует
        полученный им IP-адрес. Например, когда IP-адрес сервера домена .com
        кэшируется DNS-сервером, любые последующие запросы к домену .com
        обрабатываются без запуска механизмов повторяющихся запросов DNS
      </li>
    </ul>
    <h2>
      Функциональные требования в шаблонах двухуровневых моделей клиент-сервер
    </h2>
    
        <table>
            <thead>
                <tr>
                    <th>
                        <div>
                            <div>Функцилнальная роль</div>
                        </div>
                    </th>
                    <th>Описание</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Службы представления</td>
                    <td>
                        <div>
                            <div>Обеспечивает пользовательский интерфейс и диалоговое управление</div>
                        </div>
                    </td>
                </tr>
                <tr>
                    <td>Службы логики представления</td>
                    <td>
                        <div>
                            <div>Взаимодействие с пользователем и проверка правильности вводимых данных</div>
                        </div>
                    </td>
                </tr>
                <tr>
                    <td>Бизнес-логика</td>
                    <td>
                        <div>Набор бизнес-правил, определяющих, как можно хранить,</div>
                        <div>создавать и изменять данные</div>
                    </td>
                </tr>
                <tr>
                    <td>Логика распространения</td>
                    <td>Управление коммуникациями</td>
                </tr>
                <tr>
                    <td>Логика СУБД</td>
                    <td>Операции с данными и управление целостностью данных</td>
                </tr>
                <tr>
                    <td>Службы СУБД</td>
                    <td>Управление различными атрибутами транзакций базы данных</td>
                </tr>
                <tr>
                    <td>Файловые службы</td>
                    <td>Операции с файлами и общий доступ к файлам</td>
                </tr>
            </tbody>
        </table>
        </div>
    <h2>Распределение функциональных ролей в схеме клиент сервер</h2>    
    <p>В самом широком смысле системы клиент сервер делятся на:</p>
    <ul>
        <li><b>Схемы с "толстым" клиентом:</b> Большинство функциональных служб выполняются клиентским компонентом. Классическим примером толстого клиента является файловый сервер</li>
        <li><b>Схемы с "тонким" клиентом:</b> Большинство функциональных служб выполняются серверным компонентом (и он же берет на себя вычислительную нагрузку)</li>
    </ul>
    <p>Выбор клиента производится в зависимости от типа схемы клиент-сервер, которая запланирована в системе. Например, если схема предусматривает выполнение большого количества функций
        на стороне клиента, то имеет смысл перенести все на сторону клиента, и наоборот.  Функциональные требования, которые обсуждаются в этом разделе, дадут более полное представление о
        выборе клиентских и серверных подходов для реализации конкретных шаблонов взаимодействия клиент-сервер.</p>
    <p>Существуют различные способы реализации функционала в шаблоне клиент-сервер. Ниже приведены некоторые из наиболее распространенных способов:</p>
    <ul>
        <li>шаблон remote data access</li>
        <li>шаблон remote presentation</li>
        <li>шаблон split logic</li>
    </ul>
    <h2>Шаблон remote data access</h2>
    <p>В схеме remote data access приложение находится в клиентском компоненте, в то время как управление данными осуществляется серверным компонентом. Сервер, который выполняет управление данными, обычно называется сервером системы управления базами данных
         (СУБД) или сервером данных. СУБД продукты обычно предоставляют уровень или компонент программного обеспечения на стороне клиента, который
         управляет взаимодействием с сервером данных. Этот компонент программного обеспечения предоставляет средство data manipulation language (DML). 
         Клиентские системы поддерживают представление и бизнес-логику и взаимодействуют с сервером данных с помощью DML. Эти модели обычно предполагают использование толстого клиента, поскольку значительный объем обработки также выполняется клиентскими системами.
         Распределение функционала в архитектуре remote data access показана на следующей диаграмме:</p>
         <img src="./media/04_remote_data.png" />
         <h2>Шаблон remote presentation</h2>
         <p>В схеме remote presentation интерфейс пользователя (GUI) сопоставляется с экранной формой существующего приложения при помощи текстового представления. 
            Типичный режим работы этого шаблона предполагает использование рабочих станций, которые оснащены возможностью перехватывать текстовые
            потоки данных, отправляемые с серверной системы, и отображать их на экране. В этих системах обработка и вычисления происходят только на стороне сервера. 
            По похожей схеме работает обычный браузер, но наличие возможности скриптовой обработки отличает эту схему от remote presentation. Одним из идеальных примеров такой реализации является IBM 3270 (мэйнфрейм). 
            В этой схеме данные формируются на мейнфрейме. Затем данные отправляются на клиентскую рабочую станцию в виде потока данных размером 3270 пикселей. Клиентская рабочая станция получает данные, интерпретирует их и преобразует
            в графическую форму для отображения в окне. Если пользователь вводит какие-либо данные через клиентскую рабочую станцию в окне графического интерфейса пользователя, то приложение front ware, которое запускается на клиенте
             рабочая станция преобразует данные в формат, совместимый с 3270, и отправляет их обратно на сервер для выполнения дальнейших действий. Разделение функций в схеме клиент-сервер удаленной презентации
            показано на следующей диаграмме:</p> 
            <img src="./media/05_remote_presentation.png" />    
        <h2></h2>
        <p>В модели split logic функциональность приложения разделена на две части: одна будет реализована на стороне клиента, а другая на стороне сервера. Этот шаблон является очень сложным по сравнению с
            двумя другими шаблонами, поскольку для его функционирования и клиенту, и серверу требуются отдельно скомпилированные прикладные программы. Перед внедрением этого шаблона разработчикам очень важно
            определить функции, которые должны быть реализованы на стороне клиента и сервера, и составить список необходимых функций и экранных форм, которые должны выполняться на стороне клиента и сервера. Такая схема показана на следующей диаграмме:</p>
            <img src="./media/06_split_logic.png" />            
  </body>
</html>
