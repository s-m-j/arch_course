---
layout: default
---

<!DOCTYPE html>
<html>
  <head>
    <title>Клиент-серверные многозвенные архитектуры</title>
  </head>
  <body>
    <h1>Клиент/Сервер и многозвенные архитектурные шаблоны</h1>
    <p>
      В этом разделе приведен высокоуровневый обзор архитектурных шаблонов
      клиент-сервер. Мы начинаем с двухуровневых моделей клиент-сервер и увидим
      как ограничения двухуровневых моделей клиент-сервер привели к разработке
      трехуровневых и затем n-уровневых моделей клиент-сервер. Также кратко
      рассмотрим такие вариации клиент-серверной модели как master-slave,
      peer-to-peer с примерами использования. Завтем мы рассмотрим типовые
      фреймворки веб-приложений. Требования к веб-приложениям отличаются от
      требований к классическим клиент-серверным приложениям, и ключевым
      отличительным фактором является динамическое обновление пользовательского
      интерфейса на основе изменений в базе данных. Мы постараемся рассмотреть
      наиболее популярные шаблоны, используемые при разработке веб-приложений
    </p>
    <p>Основные темы этой части</p>
    <div>
      <ul>
        <li>2-звенные, 3-звенные и n-звенные шаблоны</li>
        <li>шаблон master-slave</li>
        <li>шаблон per-to-peer</li>
        <li>распределенная клиент-серверная модель</li>
        <li>шаблон model-view-controller</li>
        <li>шаблон model-view-presenter</li>
        <li>шаблон model-view-model</li>
        <li>шаблон front controller</li>
        <li>типовые шаблоны веб-приложений</li>
      </ul>
    </div>
    <p>
      Модель клиент сервер это один из старейших архитектурных шаблонов. Он
      описывает коммуникацию двух разных частей, клиентской и серверной
    </p>
    <ul>
      <li>
        Клиент: инициатор соединения, является потребителем услуг которые
        предоставляет сервис в ответ на запросы клиента
      </li>
      <li>
        Сервер: компонент, который является поставщиком услуг и предоставляет
        услуги клиенту в соответствии с поступающими от клиента запросами
      </li>
    </ul>
    <p>
      Клиент и сервер обычно составляют распределенную систему и взаимодействуют
      используя коммуникационную сеть
    </p>
    <p></p>
    <p>
      Не существует принципиального ограничения количества клиентов, которые
      могут обслуживаться одним сервером. Также не обязательно, чтобы клиент и
      сервер находились в разных системах. Связь между клиентом и сервером
      осуществляется путем обмена сообщениями по схеме "запрос-ответ". Клиент
      отправляет запрос на обслуживание, а сервер возвращает ответ. Эта схема
      взаимодействия "запрос-ответ" является примером межпроцессного
      взаимодействия. Для эффективного взаимодействия необходимо иметь четко
      определенный протокол связи, устанавливающий правила взаимодействия, такие
      как формат сообщений, правила обработки ошибок и так далее. Все
      коммуникационные протоколы, используемые для взаимодействия клиент-сервер,
      работают на прикладном уровне стека протоколов. Для дальнейшей оптимизации
      в процессе взаимодействия клиент-сервер сервер иногда реализует
      специальные интерфейсы прикладного программирования (API), которые могут
      быть использованы клиентом для доступа к какой-либо конкретной услуге с
      сервера. Шаблон клиент-сервер, изображенный на рисунке, имеет два уровня:
      клиентский и серверный, и поэтому его также называют двухуровневым
      шаблоном или двухуровневой системой клиент-сервер
    </p>
    <img src="./media/01_client_server.png" />
    <p>
      Термин "сервис", используемый в контексте клиент-серверной архитектуры,
      относится к абстракции ресурса. Ресурс может быть любого типа, а имя
      сервера определяется на основе ресурса, который предоставляется сервером
      (сервис). Например, если сервер предоставляет веб -страницы, он называется
      веб-сервером, а если сервер предоставляет файлы, он называется файловым
      сервером и т.д. Сервер может получать запросы от множества клиентов в
      любой момент времени. Но любой физический сервер имеет ограничения
      возможностей обработки потока сообщений. Поэтому часто сервер должен
      определять приоритет входящих запросов и обслуживать их в соответствии с
      их приоритетом. Система планирования, используемая на сервере, помогает
      серверу в распределении приоритетов. Ниже приведены общие области
      применения шаблонов клиент-сервер для различных случаев использования.
    </p>
    <p>
      Email сервер и email коиент: Сервер отправляет письма в ответ на запрос с
      клиента. Примеры - Microsoft Exchange от Microsoft, Gmail от Google И
      другие. Работу такой почтовой системы можно описать так:
    </p>
    <img src="./media/02_mail_system.png" />
    <p>
      Когда вы отправляете письмо, приложение почтового клиента связывается с
      почтовым сервером по протоколу SMTP и загружает содержимое на сервер.
      Когда оно загружено, почтовая система доставляет письмо на другой сервер,
      который использует протокол POP3 для обслуживания клиентского ПО
      доставляющего письмо адресату. Подробное описание этого процесса это не
      тема этого документа, но если тема заинтересовала - можно почитать
      <a href="https://emailsoldiers.ru/glossary/email-protocol">статью</a>.
    </p>
    <h2>Сервер доменных имен (DNS) и DNS-клиент</h2>
    <p>
      DNS - одна из самых важных служб, существующих в Интернете. В Интернете
      есть огромное количество устройств, и каждое из этих устройств называется
      хостом. Каждый хост может быть принтером, маршрутизатором, компьютером или
      любым другим устройством. Каждый хост имеет уникальный адрес, называемый
      IP-адресом. Помимо IP-адреса, с каждым хостом также связано уникальное имя
      хоста. Например, если имя хоста равно LP231 и он присутствует в домене
      acme.com, то полное доменное имя (FQDN) хоста равно LP231.acme.com. Полное
      доменное имя используется для уникальной идентификации хоста в
      пространстве имен DNS. Пространство имен DNS содержит несколько часто
      используемых суффиксов имен, например:
    </p>
    <ul>
      <li>.com: коммерческие организации</li>
      <li>.org: некоммерческие организации</li>
      <li>.edu: учебные учреждения</li>
    </ul>
    <h2>Работа системы DNS</h2>
    <p>
      Система DNS работает с использованием концепции распределенных баз данных,
      основанной на модели клиент-сервер. DNS-клиенты - это объекты, которым
      требуется разрешение имен (сопоставление имен хостов с IP -адресами).
      DNS-серверы поддерживают данные, необходимые для разрешения имен.
      Высокоуровневая схема архитектуры DNS клиент-сервер приведена на следующей
      диаграмме:
    </p>
    <img src="./media/03_dns_system.png" />
    <p>
      Предположим, что URL-адрес www.acme.com введен в браузере DNS-клиента.
      Браузер подключается к DNS-серверу, чтобы получить IP-адрес
      соответствующий доменному имени. DNS-сервер выполняет эту задачу, сначала
      подключаясь к одному из корневых (root) DNS-серверов. Корневые серверы
      хранят IP-адреса всех DNS-серверов, которые обрабатывают домены верхнего
      уровня, такие как .edu, .com и так далее. В этом примере корневой сервер,
      получив IP-адрес домена верхнего уровня .com отправляет в ответ адрес TLD
      DNS сервера, который обрабатывает адреса домена acme.com. Этот сервер, в
      свою очередь, возвращает полный полный IP-адрес, который отпраялется
      обратно клиенту, который инициировал запрос DNS. Затем компьютер-клиент
      DNS может использовать IP-адрес для доступа к требуемой веб-странице.
      Подробнее о процессе можно почитать
      <a href="https://blog.skillfactory.ru/glossary/dns/">здесь</a>.
    </p>
    <p>Основными аспектами этой клиент-серверной архитектуры являются:</p>
    <ul>
      <li>
        <b>Избыточность (Redundancy):</b> На каждом уровне имеется несколько
        DNS-серверов, так что даже в случае сбоя одного из них другой сервер
        может взять на себя его роль.
      </li>
      <li>
        <b>Кэширование:</b>Как только DNS-запрос разрешен, DNS-сервер кэширует
        полученный им IP-адрес. Например, когда IP-адрес сервера домена .com
        кэшируется DNS-сервером, любые последующие запросы к домену .com
        обрабатываются без запуска механизмов повторяющихся запросов DNS
      </li>
    </ul>
    <h2>
      Функциональные требования в шаблонах двухуровневых моделей клиент-сервер
    </h2>
    
        <table>
            <thead>
                <tr>
                    <th>
                        <div>
                            <div>Функцилнальная роль</div>
                        </div>
                    </th>
                    <th>Описание</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Службы представления</td>
                    <td>
                        <div>
                            <div>Обеспечивает пользовательский интерфейс и диалоговое управление</div>
                        </div>
                    </td>
                </tr>
                <tr>
                    <td>Службы логики представления</td>
                    <td>
                        <div>
                            <div>Взаимодействие с пользователем и проверка правильности вводимых данных</div>
                        </div>
                    </td>
                </tr>
                <tr>
                    <td>Бизнес-логика</td>
                    <td>
                        <div>Набор бизнес-правил, определяющих, как можно хранить,</div>
                        <div>создавать и изменять данные</div>
                    </td>
                </tr>
                <tr>
                    <td>Логика распространения</td>
                    <td>Управление коммуникациями</td>
                </tr>
                <tr>
                    <td>Логика СУБД</td>
                    <td>Операции с данными и управление целостностью данных</td>
                </tr>
                <tr>
                    <td>Службы СУБД</td>
                    <td>Управление различными атрибутами транзакций базы данных</td>
                </tr>
                <tr>
                    <td>Файловые службы</td>
                    <td>Операции с файлами и общий доступ к файлам</td>
                </tr>
            </tbody>
        </table>
        </div>
    <h2>Распределение функциональных ролей в схеме клиент сервер</h2>    
    <p>В самом широком смысле системы клиент сервер делятся на:</p>
    <ul>
        <li><b>Схемы с "толстым" клиентом:</b> Большинство функциональных служб выполняются клиентским компонентом. Классическим примером толстого клиента является файловый сервер</li>
        <li><b>Схемы с "тонким" клиентом:</b> Большинство функциональных служб выполняются серверным компонентом (и он же берет на себя вычислительную нагрузку)</li>
    </ul>
    <p>Выбор клиента производится в зависимости от типа схемы клиент-сервер, которая запланирована в системе. Например, если схема предусматривает выполнение большого количества функций
        на стороне клиента, то имеет смысл перенести все на сторону клиента, и наоборот.  Функциональные требования, которые обсуждаются в этом разделе, дадут более полное представление о
        выборе клиентских и серверных подходов для реализации конкретных шаблонов взаимодействия клиент-сервер.</p>
    <p>Существуют различные способы реализации функционала в шаблоне клиент-сервер. Ниже приведены некоторые из наиболее распространенных способов:</p>
    <ul>
        <li>шаблон remote data access</li>
        <li>шаблон remote presentation</li>
        <li>шаблон split logic</li>
    </ul>
    <h2>Шаблон remote data access</h2>
    <p>В схеме remote data access приложение находится в клиентском компоненте, в то время как управление данными осуществляется серверным компонентом. Сервер, который выполняет управление данными, обычно называется сервером системы управления базами данных
         (СУБД) или сервером данных. СУБД продукты обычно предоставляют уровень или компонент программного обеспечения на стороне клиента, который
         управляет взаимодействием с сервером данных. Этот компонент программного обеспечения предоставляет средство data manipulation language (DML). 
         Клиентские системы поддерживают представление и бизнес-логику и взаимодействуют с сервером данных с помощью DML. Эти модели обычно предполагают использование толстого клиента, поскольку значительный объем обработки также выполняется клиентскими системами.
         Распределение функционала в архитектуре remote data access показана на следующей диаграмме:</p>
         <img src="./media/04_remote_data.png" />
         <h2>Шаблон remote presentation</h2>
         <p>В схеме remote presentation интерфейс пользователя (GUI) сопоставляется с экранной формой существующего приложения при помощи текстового представления. 
            Типичный режим работы этого шаблона предполагает использование рабочих станций, которые оснащены возможностью перехватывать текстовые
            потоки данных, отправляемые с серверной системы, и отображать их на экране. В этих системах обработка и вычисления происходят только на стороне сервера. 
            По похожей схеме работает обычный браузер, но наличие возможности скриптовой обработки отличает эту схему от remote presentation. Одним из идеальных примеров такой реализации является IBM 3270 (мэйнфрейм). 
            В этой схеме данные формируются на мейнфрейме. Затем данные отправляются на клиентскую рабочую станцию в виде потока данных размером 3270 пикселей. Клиентская рабочая станция получает данные, интерпретирует их и преобразует
            в графическую форму для отображения в окне. Если пользователь вводит какие-либо данные через клиентскую рабочую станцию в окне графического интерфейса пользователя, то приложение front ware, которое запускается на клиенте
             рабочая станция преобразует данные в формат, совместимый с 3270, и отправляет их обратно на сервер для выполнения дальнейших действий. Разделение функций в схеме клиент-сервер удаленной презентации
            показано на следующей диаграмме:</p> 
            <img src="./media/05_remote_presentation.png" />    
        <h2></h2>
        <p>В модели split logic функциональность приложения разделена на две части: одна будет реализована на стороне клиента, а другая на стороне сервера. Этот шаблон является очень сложным по сравнению с
            двумя другими шаблонами, поскольку для его функционирования и клиенту, и серверу требуются отдельно скомпилированные прикладные программы. Перед внедрением этого шаблона разработчикам очень важно
            определить функции, которые должны быть реализованы на стороне клиента и сервера, и составить список необходимых функций и экранных форм, которые должны выполняться на стороне клиента и сервера. Такая схема показана на следующей диаграмме:</p>
            <img src="./media/06_split_logic.png" />            
        <h1>Трех- и Многозвенные шаблоны клиент-серверной модели</h1>
        <P>Рассмотрим еще несколько вариаций клиент-серверной модели. Вот еще два типовых случая:</P>
        <ul>
            <li>шаблон master-slave </li>
            <li>шаблон peer-to-peer</li>
        </ul>
        <p>Рассмотрим их подробнее</p>    
        <h2>Master-slave</h2>
        <p>Шаблон master-slave применяется при проектировании системы, если система включает в себя аналогичные или похожие вычисления, которые необходимо выполнять повторно с разными наборами входных данных и
            контекстом. Шаблон master-slave обеспечивает отказоустойчивость и параллельные вычисления.</p>
        <p>Главный компонент распределяет работу между всеми подчиненными компонентами и вычисляет конечный результат, суммируя результаты, которые возвращает каждый подчиненный компонент. Шаблон master-slave
            используется для проектирования встраиваемых систем и используется при проектировании систем, которые выполняют массовые параллельные вычисления. Ниже приведена схема последовательности
            действий шаблона master slave:</p>
        <img src="./media/07_master_slave.png" />
        <h2>Возможные применения шаблона master-slave</h2>   
        <p>Схема "главный-подчиненный" работает по принципу "разделяй и властвуй". При использовании этой схемы концепция координации отделена от реальной работы, поскольку все подчиненные
            устройства работают параллельно. Следовательно, у подчиненных устройств нет общего состояния, они работают изолированно. Проблемой в шаблоне master slave является потенциальная задержка. 
            Это может вызвать проблему в системах, где время отклика очень важно. Этот может быть применен к конкретной проблеме, только если она поддается декомпозиции.</p>
        <p>Один из способов реализации шаблона master-slave заключается в использовании одного главного потока, который создает несколько подчиненных потоков. Каждый из подчиненных потоков выполняет часть
            общего вычисления и возвращает результат главному потоку. Как только вычисление завершено, главный поток объединяет результаты и завершает работу подчиненных потоков.</p>
        <h2>Peer-to-peer</h2>    
        <p>Peer-to-peer архитектурные шаблоны относятся к категории симметричных клиент-серверных
            шаблонов. Симметричность в данном контексте означает, что одна и та же система может выполнять функции клиента и сервера. Такая система, также называемая одноранговой, отправляет запросы
            другим одноранговым узлам в сети и в то же время получает и обслуживает запросы от других одноранговых узлов. </p>
        <p>Этот шаблон обычно используется для реализации децентрализованной сети узлов, использующих распределенные ресурсы. Распределенными
            ресурсами могут быть либо вычислительные мощности, либо данные, которые могут использоваться для задач распределенных вычислений, 
            таких как совместное использование контента, коммуникация и так далее. Общий шаблон одноранговоой системы показан на следующей диаграмме (однако возможны некоторые
            вариации):</p>
        <img src="./media/08_peer_2_peer.png" />
        <p>Есть два самых распространенных варианта реализации такого шаблона:</p>
        <ul>
            <li><B>pure peer-to_peer:</B> сервер используется только как промежуточное звено связи клиентов, не имеет никакой логики и никак не влияет на работу системы в уцелом. Примером такой реализации является протокол обмена файлами Gnutella</li>
            <li><B>гибридная peer-to_peer:</B> сервер выполняет некоторые административные функции, помогая работе клиентов. Примером такой реализации является протокол Napster</li>
        </ul>
        <p>Хотя схемы peer-to-peer очень эффективны для таких приложений, как общий доступ к файлам, они также
            предоставляют возможности для реализации множества угроз безопасности. TCP-порты, используемые одноранговыми приложениями, должны постоянно контролироваться 
            и находиться под наблюдением систем предотвращения вторжений.</p>
        <h2>Преимущества двухуровневых клиент-серверных схем</h2>
        <p>Некоторые ключевые преимуществ клиент серверных систем:</p>
        <ul>
            <li>Безопасность: Данные хранятся централизованно на сервере. Это обеспечивает больший контроль и более высокий уровень безопасности, чем защита данных, которые будут
                распределены по большому количеству клиентских компьютеров.</li>
            <li>Централизованный доступ к данным: Поскольку большая часть данных хранится централизованно на сервере,
                обновлять данные и поддерживать их согласованность намного проще. Это один из самых простых архитектурных стилей.</li>
            <li>Простота обслуживания: При такой архитектурной схеме клиент не осведомлен о деталях работы сервера, и, следовательно, действия по обслуживанию сервера мало влияют на работу клиента</li>
        </ul>
        <h2>Конструктивные соображения - когда следует использовать двухуровневую схему клиент-сервер?</h2>
        <p>После того, как мы подробно рассмотрели шаблоны клиент-сервер, возникает следующий вопрос: когда следует использовать двухуровневую схему клиент-сервер для конкретного архитектурного
            проекта. Следующие моменты могут быть использованы в качестве ориентира при принятии решения:</p>
        <ul>
            <li>Если рассматриваемое приложение имеет централизованную логику и будет поддерживать множество
                клиентов, то хорошим выбором будет двухуровневый шаблон клиент-сервер.</li>
            <li>По этой схеме часто организованы приложения которые будут использоваться внутри одной организации как рабочие места с общим центром управления</li>
            <li>Если вы хотите централизовать операции с данными, такие как хранение, резервное копирование и другие
                связанные с этим задачи администрирования, то двухуровневая структура клиент-сервер является идеальным выбором.</li>
        </ul>
        <h2>Ограничения двузвенной архитектуры</h2>
        <p>Вот главные ограничения таких систем:</p>
        <ul>
            <li>Ограниченная расширяемость и масштабируемость: В большинстве
                реализаций данные приложения и бизнес-логика хранятся на одном центральном
                сервере. Этот аспект влияет на расширяемость и масштабируемость системы, так как она ограничена мощностью центрального узла (только вертикальное масштабирование)</li>
            <li>Интенсивное использование полосы пропускания сети: при обмене данными между клиентом и
                сервером передается много данных. Данные запросов и ответов часто необходимо
                преобразовывать в общий формат, это также способствует
                увеличению трафика.</li>
        </ul>
        <p>Чтобы преодолеть эти ограничения двухуровневой модели клиент-сервер, была разработана трехуровневая/многоуровневая
            архитектура клиент-сервер. Большинство современных приложений
            , разрабатываемых с использованием архитектуры клиент-сервер, основаны на трехуровневой
            архитектурной модели</p>
        <h2>Трехуровневая архитектура</h2>
        <p>В этой архитектуре присутствуют следующие три уровня (слоя):</p>
        <ul>
            <li><b>Презентационный слой:</b> Этот уровень предоставляет услуги презентации, то есть представление
                контента конечному пользователю через графический интерфейс. Доступ к этому уровню возможен с любого
                клиентского устройства, такого как настольный компьютер, ноутбук, планшет, мобильный телефон, тонкий клиент и так далее.</li>
            <li><b>Слой бизнес логики:</b>Это уровень, на
                котором выполняется бизнес-логика приложения. Компоненты этого уровня обычно выполняются на одном или нескольких
                серверах приложений</li>
            <li><b>Слой данных:</b> Данные приложения обычно хранятся на сервере базы данных, файловом сервере или любом другом устройстве или носителе, который поддерживает
                логику доступа к данным и обеспечивает необходимые действия для обеспечения доступа только к данным без предоставления какого-либо 
                доступа к механизмам хранения и извлечения данных. Это делается на уровне данных путем предоставления API для уровня бизнес-логики. Предоставление этого API обеспечивает полную прозрачность данных
                 операции, выполняемые на этом уровне, не влияют на уровень приложений. Например, обновления систем на этом уровне не влияют на уровень приложений в данной архитектуре.</li>
        </ul>
        <img src="./media/09_3_teer.png" />
        <p>Преимсущества:</p>
        <ul>
            <li><b>Масштабируемость и гибкость: </b> Основным преимуществом этой архитектуры является ее
                масштабируемость и гибкость. Каждый уровень этой архитектуры является модульным компонентом,
                то есть любые операции, такие как изменения или обновления, выполняемые на одном уровне, не
                влияют на другие уровни и не вызывают простоев. 
                Клиентские системы на уровне представления, обладают меньшей функциональностью и не требуют сложной конфигурации.</li>
            <li><b>Дополнительная безопасность: </b>Распределение задач по различным уровням обеспечивает повышенную
                безопасность каждого уровня.</li>
        </ul>
        <p>Хотя трехуровневые архитектурные схемы дают ряд преимуществ, все еще существуют ограничения на
            масштабируемость архитектуры, когда речь заходит о таких сетях, как Интернет, которые требуют
            масштабируемости в больших масштабах.</p>
        <h2>Конструктивные соображения для выбора трехуровневой
            архитектуры</h2>
        <p>Вот несколько условий при которых 3-уровневая архитектура станет хорошим выбором:</p>    
        <ul>
            <li>Если вы разрабатываете приложение с ограниченной конфигурацией клиентских систем. В этом случае другие компоненты архитектуры, такие как бизнес-логика и логика данных, могут быть распределены по другим уровням.</li>
            <li>Если вы разрабатываете приложение для развертывания в интрасети, где все серверы расположены в частной сети.</li>
            <li>Если вы разрабатываете интернет-приложение, и у вас есть возможность развернуть веб-серверы или серверы приложений в частной сети.</li>
        </ul>
        <p>Вариантом трехуровневой архитектурной схемы, обеспечивающей масштабируемость, является n-уровневая
            архитектурная схема. В n-уровневом архитектурном шаблоне общее количество уровней равно n, где n > 3. В многоуровневой архитектуре уровень приложений (который является средним уровнем) разделен на
            множество уровней. Распределение кода приложения и функций между различными уровнями
             варьируется в зависимости от архитектурного проекта. Схема многоуровневой архитектуры выглядит следующим образом:</p>
        <img src="./media/10_n_teer.png" />
        <h2>Пример n-звенного прилложения</h2>
        <p>Примером такого приложения может быть типовой интернет-магазин, где слой презентационной логики представлен web интерфейсом или мобильным приложением, слой бизнес-логики реализуется на веб-сервере либо веб-сервере + выделенном сервере приложений и слой данных представлен выделенным звеном СУБД</p>
        <p>В такой схеме слой представления, например, отвечает за отрисовку интерфейса пользователя (каталог товаров, корзина), сервер приложений отвечает за логику (добавление товара в корзину, формирование счета на оплату) в конкретной сессии а сервер СУБД обеспечивает долговременное хранение истории операций и данных о товарах</p>
        <h2>Распределенная клиент-серверная архитектура</h2>
        <p>Многоуровневая архитектура клиент-сервер, используемая для веб-приложения, которое обсуждалось в предыдущем разделе, является хорошим примером 
            распределенной архитектуры клиент-сервер. В распределенных архитектурах обычно есть какие-то внутренние компоненты хоста (такие как мэйнфрейм, сервер баз данных и т.д.), 
            интеллектуальный клиент на уровне UI и несколько агентов посередине, которые выполняют все действия, относящиеся к транзакциям, такие как обработка транзакций, безопасность, обработка сообщений и т.д.</p>
        <p>Ключевые концепции связанные с распределенной архитектурой:</p>
        <ul>
            <li><b>Обработка транзакций: </b>Обработка транзакций - это автоматизированная обработка
                с целью обновления общей базы данных. Приложение для обработки транзакций
                , как правило, имеет множество пользователей, которые одновременно взаимодействуют
                с системой для обработки бизнес-транзакций в общей базе данных</li>
            <li><b>Монитор обработки транзакций (TP monitor):</b> Основной задачей монитора транзакций
                является эффективное управление потоком транзакций через клиент-серверную систему.
                 Он работает чтобы гарантировать, что одновременные транзакции, выполняемые в общей базе данных, не приводят к несогласованности данных в базе данных</li>
        </ul>
        <p> Мониторы транзакций также предоставляют сервисы, которые помогают отслеживать транзакции, балансировать нагрузку и позволяют автоматически перезапускать серверы и существующие на них очереди</p>
        <h1>Мотивация для разработки шаблонов веб-приложений</h1>
        <p>Большинство веб-приложений интерактивны по своей природе. Это означает, что при внесении изменений в данные они должны отражаться в пользовательском интерфейсе мгновенно, без каких-либо дальнейших
            задержек. В дополнение к этому сценарию различным пользователям приложения могут потребоваться выходные данные в
            различных форматах, таких как таблицы Excel, столбчатые диаграммы, круговые диаграммы, информационные панели и т.д., как показано
            на следующей диаграмме:</p>
        <img src="./media/12_web_mvю.png" />
        <p>Когда происходит изменение функциональности конкретного приложения, пользовательский интерфейс
            приложения также должен быть способен отражать изменения с добавлением новых опций, таких как
            меню, выпадающие списки и так далее. Это подчеркивает тот факт, что пользовательские интерфейсы веб-приложений всегда подвергаются серии запросов на изменение. 
            Эти запросы на изменение (UI) могут возникать при различных обстоятельствах, например:</p>
        <ul>
            <li>Запрос от конечного пользователя/заказчика на изменение функции пользовательского интерфейса по различным
                причинам, таким как простота использования, адаптивность и так далее</li>
            <li>Перенос системы на другую платформу</li>
            <li>Изменение модели данных</li>
    
        </ul>
        <p>Из этого мы можем сделать вывод, что пользовательские интерфейсы всегда подвержены изменениям. Разные пользователи
            приложения предъявляют к пользовательскому интерфейсу разные типы противоречивых требований. Например, интерфейс руководителя - пользователя отчености и интерфейс администратора отчетов будет различаться детализацией. 
            Все это требует наличия пользовательского интерфейса, дизайн которого является достаточно гибким, чтобы
            реализовать все типы пользовательского интерфейса. Невозможно создать систему с такой гибкостью, если пользовательский интерфейс жестко привязан 
            к функциональному ядру приложения. В таком случае пришлось бы создать и поддерживать несколькио типов программных приложений, по одному для каждого типа 
            пользовательского интерфейса, что было бы очень дорого. Ниже приведены основные аспекты, которые необходимо учитывать при разработке шаблонов проектирования для веб-приложений:</p>
        <ul>
            <li>Должна быть предусмотрена возможность представления одной и той же информации в разных форматах в
                разных окнах, например, в одном окне в виде круговой диаграммы, в другом окне
                в виде листа Excel и так далее</li>
            <li>Должна быть возможность легко изменять пользовательский интерфейс без пересборки приложения</li>
        </ul>
        <p>Эти факторы стали мотивацией для разработки шаблона model view controller (MVC), который в основном используется для проектирования 
            и разработки мобильных и веб-приложений. Ниже приведены основные компоненты архитектурного шаблона MVC:</p>
        <ul>
            <li><b>Модель:</b> в MVC инкапсулироет основные данные и логику. Компонент model способен функционировать
                независимо от уровня представления. С точки зрения проектирования, модель, по сути, представляет собой набор классов, которые используются для
                описания бизнес-логики.</li>
            <li><b>View:</b> отвечает за интерфейс взаимодействия с пользователем. Компонент view получает данные для отображения из модели. Модель
                может иметь любое количество представлений в зависимости от требований приложения. С точки зрения дизайна, представление, по сути, 
                отображает компоненты пользовательского интерфейса, такие как HTML, jQuery и так далее.</li>
            <li><b>Controller:</b> Каждое представление связано с контроллером. Контроллеры получают входные данные,
                обычно в виде событий от пользователя. События могут быть получены в
                виде щелчков мыши, нажатий клавиш с клавиатуры и так далее. Эти события
                преобразуются в запросы на обслуживание и передаются в модель или представление. 
                Контроллер - это единственный компонент, с помощью которого пользователь взаимодействует с
                системой.</li>
        </ul>   
        <p>Разделение компонентов model, view и controller обеспечивает гибкость, позволяя использовать несколько представлений (view) одной и той же модели. 
            В случае, если пользователь изменит данные модели, используя компонент controller в одном view, все другие мшуц, использующие те же данные, должны быть
            немедленно обновлены, чтобы отразить изменения. Об этом заботится модель, уведомляя все view при каждом изменении своих данных. 
            Представление, в свою очередь, берет обновленные данные из модели и обновляет интерфейс. Эти действий требуют наличие механизма распространения изменений в модели MVC. 
            </p>
        <h2>Работа шаблона MVC</h2>
        <p>Компонент model экспортирует процедуры для обработки, специфичной для конкретного приложения. Эти
            процедуры вызываются компонентами контроллера в ответ на входные данные, полученные от
            пользователя. Компонент model также предоставляет функции, которые могут использоваться компонентом view
            для доступа к своим данным.</p>
        <p>Компоненты View используются для представления информации конечному пользователю. Могут существовать
            различные представления для предоставления информации различными способами в соответствии с требованиями
            пользователей. Каждое представление связано с процедурой обновления, которая активируется
            механизмом распространения изменений. Механизм распространения изменений работает путем ведения
            реестра всех зависимых компонентов, присутствующих в модели. Все связанные представления и контроллеры, на которые повлияют изменения в этих компонентах, 
            также регистрируются. Любое изменение состояния модели запускает механизм распространения изменений. Компонент view получив от системы распространения изменений сообщение, 
            извлекает из модели обновленные значения данных и отображает их на экранах пользовательского интерфейса</p>    
        <p>Компонент контроллера принимает пользовательский ввод в виде событий. Формат, в котором эти
            данные о событиях передаются на контроллер, зависит от платформы пользовательского интерфейса. Но в любом случае контроллер выполняет процедуру обработки событий, 
            связанную с полученым событием. Общая схема работы шаблона MVC показана на рисунке:</p>
            <img src="./media/13_mvc_model.png" />
        <p>Рассмотрим популярный фреймворк построеный по такой модели</p>
        <h2>ASP.Net framework</h2>
        <p>В ASP.Net шаблоны для компонента представления и компонента контроллера определены фреймворком. Разработчику остается разработать только компонент модели
            в соответствии с конкретными требованиями приложения</p>
        <p><b>View:</b> Файлы ASPX и ASCX выполняют функции, связанные с компонентом view. В этом случае объект view обычно наследуется от объекта controller</p>
        <p><b>Контроллер:</b> Обязанности компонента controller разделены между двумя компонентами. Генерация и передача событий осуществляется платформой, а именно классами Page и Control. </p>
        <p><b>Model:</b> ASP.NET не требует обязательного использования модели. Выбор за разработчиком, создавать ли класс model или отказаться от него. В случае, если модель не используется, 
            обработчики событий в контроллере могут использоваться для выполнения любых вычислений, а также для сохранения данных.</p>
        <h2>Шаблон model view presenter (MVP) </h2>
        <p>Шаблон MVP является вариантом шаблона MVC и в основном используется для разработки
            пользовательских интерфейсов для веб-приложений. В основном он был разработан для упрощения
            автоматизированного модульного тестирования. На приведенном здесь рисунке показана архитектура шаблона MVP:</p>
        <img src="./media/14_mvp_model.png" />
        <p>Компоненты MVP</p>
        <ul>
            <li><b>Модель:</b> Этот компонент определяет данные, которые будут отображаться/отправляться из пользовательского интерфейса или в него.</li>
            <li><b>Представление: </b>Логика представления находится в компоненте Presenter. Он работает как с моделью, так и с компонентами view. Он отвечает за извлечение 
                данных из модели, применение соответствующей логики и отправку их обратно для отображения в представлении. По сравнению с компонентами представления и контроллера в модели MVC, компоненты
                представления и презентатора, представленные в шаблоне MVP, полностью отделены друг от друга и взаимодействуют посредством интерфейса.</li>
            <li><b>Presenter:</b> Компонент view действует как пассивный интерфейс. Он отображает данные из модели и отправляет пользовательские данные и команды компоненту presenter. 
                Эти пользовательские данные и команды будут использоваться для выполнения операций с данными.</li>
        </ul>
        <p>Вот ключевые сошлашения подхода MVP:</p>
        <ul>
            <li>Пользователь взаимодействует только с View</li>
            <li>Один компонент View связан только с одним Presenter</li>
            <li>View связан с Presenter но не имеет связи с компонентом Model</li>
            <li>Шаблон предусматривает двустороннюю связь между компонентом View и компонентом Presenter</li>
        </ul>
        <p>Примерами применения этого подхода являются ASP.Net forms и Windows forms.</p>
        <h2>Шаблон model-view-viewmodel (MVVM)</h2>
        <p>MVVM - популярный шаблон, используемый для разработки повторно используемых и легко тестируемых веб-приложений. MVVM - это современный вариант MVC, основная цель 
            которого - обеспечить четкое разделение между компонентами Model и View. Основными компонентами шаблона являются следующие:</p>
        <ul>
                <li>Model</li>
                <li>View</li>
                <li>ViewModel</li>
        </ul>
        <b>Многоуровневая архитектура шаблона изображена на следующей диаграмме:</b>
        <img src="./media/15_mmvm_model.png" />
        <p>Составные части MVVM:</p>
        <ul>
            <li><b>Model: </b>отвечает за бизнес логику и модель данных</li>
            <li><b>View: </b>представляет компоненты пользовательского интерфейса и, по сути, будет содержать
                элементы пользовательского интерфейса, такие как CSS, HTML и т.д. Он отвечает только за представление данных и
                не выполняет никаких манипуляций с данными. Однако, представление в MVVM является
                активным компонентом и содержит поведение, события и привязки данных, для которых требуется
                информация о базовой модели и компонентах ViewModel.</li>
            <li><b>ViewModel: </b>является очень важным компонентом архитектуры, поскольку помогает отделить представление от модели и в
                то же время действует как контроллер, который поддерживает взаимодействие и координацию между
                представлением и компонентом модели. Компонент ViewModel также содержит команды и
                методы, которые помогают поддерживать состояние представления и помогают манипулировать моделью в соответствии
                с действиями, которые выполняются с представлением. Компонент ViewModel также помогает
                запускать события в самом компоненте view</li>
        <h2>Преимущества модели MVVM:</h2>
        <p>Ниже приведены ключевые преимущества использования шаблона MVVM:</p>
        <ul>
            <li><p>Удобство сопровождения: </p>В этом шаблоне четкое разделение различных фрагментов кода упрощает его обслуживание, а также обеспечивает быстрое обновление.</li>
            <li><p>Тестируемость: </p>В этом шаблоне различные фрагменты кода очень детализированы и отделены от основной функциональной логики. Это очень упрощает модульное тестирование.</li>
            <li><p>Расширяемость: </p>Детализированные фрагменты кода облегчают повторное использование кода, а также позволяют быстро вносить изменения в кодовую базу</li>
        </ul>
        <h2>Предпосылки к использованию MVVM</h2>
        <p>Шаблон MVVM - это правильный выбор для разработки веб-приложений, требующих соблюдения следующего:</p>
        <ul>
            <li>Тщательное модульное тестирование различных компонентов</li>
            <li>Вы хотите обеспечить повторное использование кода</li>
            <li>Вы хотите обечспечить гибкое изменение пользовательского интерфейса без изменения кодовой базы</li>
        </ul>
        <p>Рассмотрим фреймворк построеный та таком шаблоне</p>
        <h2>Prism</h2>
        <P>Prism - это фреймворк, созданный с использованием шаблона MVVM. Он помогает в проектировании и
            разработке гибких и простых в обслуживании приложений Windows presentation foundation (WPF). Ниже приведены ключевые особенности фреймворка Prism:</P>
        <ul>
            <li>В нем используется архитектурный шаблон, который поддерживает важные концепции проектирования, такие как
                разделение задач и слабосвязанные компоненты.</li>
            <li>Prism помогает в разработке фрагментов кода/компонентов, которые могут быть легко
                интегрированы в приложение. Приложения такого типа, которые создаются путем
                интеграции компонентов, называются составными приложениями</li>
        </ul>    
        <p>Вот основные возможности Prism:</p>
        <ul>
            <li>Поддерживается шаблон MVVM, который, в свою очередь, предоставляет базовый класс bindable.</li>
            <li>Реализован гибкий ViewModelLocator, который позволяет
                подключать компоненты View и ViewModel в произвольном порядке. Он обеспечивает полную поддержку
                разработки модульных приложений, поскольку имеет несколько слабо связанных
                библиотек классов. Эти библиотеки могут быть объединены во время выполнения в виде
                приложения для конечного пользователя. База кода по-прежнему остается разделенной.</li>
            <li>Поддерживает широкий набор навигационных функций, таких как прямая
                навигация, обратная навигация и т.д. Навигационный стек prism позволяет
                 ViewModels напрямую участвовать в процессе навигации.</li>
            <li>Prism поддерживает концепцию событий Pub/Sub. Они относятся к механизму
                слабо связанных событий, при котором компоненты publisher и subscriber могут
                взаимодействовать с помощью событий. При этом необязательно, чтобы компоненты publisher или
                subscriber имели явные ссылки друг на друга или одинаковое время жизни.</li>

        </ul>

    </ul>
    <h1>Специализированные паттерны для WEB-приложений</h1>
    <p>Помимо архитектурных шаблонов MVC, MVP и MVVM, некоторые классические паттерны проектирования часто используются при создании веб-приложений. Такие шаблоны и их
        функциональные возможности описаны в следующей таблице:</p>
        <div class="table_component" role="region" tabindex="0">
            <table>
                <thead>
                    <tr>
                        <th>
                            <div>
                                <div>Паттерн</div>
                            </div>
                        </th>
                        <th>Функциональность</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Интерпретатор (Interpreter)</td>
                        <td>
                            <div>Этот шаблон широко используется при разработке меню для приложений например, таких как редакторы и интегрированные среды разработки (IDE). Этот</div>
                            <div>шаблон работает путем интерпретации инструкций, написанных в форме грамматики языка. Этот шаблон включает в себя реализацию интерфейса expression, который используется для интерпретации</div>
                            <div>заданного выражения</div>
                        </td>
                    </tr>
                    <tr>
                        <td>Снимок (Memento)</td>
                        <td>
                            <div>Позволяет фиксировать текущее состояние</div>
                            <div>объекта и восстанавливать его, когда это потребуется.</div>
                        </td>
                    </tr>
                    <tr>
                        <td>Наблюдатель (Observer)</td>
                        <td>Этот шаблон позволяет одному объекту, называемому subject, уведомлять об изменениях своего состояния все другие объекты (observer), которые зависят от него.</td>
                    </tr>
                    <tr>
                        <td>Состояние (State)</td>
                        <td>Позволяет объекту изменять свое поведение в зависимости от внутреннего состояния</td>
                    </tr>
                    <tr>
                        <td>Стратегия (Strategy)</td>
                        <td>Определяет общее поведение для семейств схожих алгоритмов, использующих разные стратегии</td>
                    </tr>
                    <tr>
                        <td>Шаблонный метод (Template Method)</td>
                        <td>Предлагает <em>разбить алгоритм на последовательность шагов</em>, описать эти шаги в отдельных методах и вызывать их в одном шаблонном методе</td>
                    </tr>
                    <tr>
                        <td>Посетитель (Visitor)</td>
                        <td>Позволяет добавлять в программу новые операции, не изменяя классы объектов, над которыми эти операции осуществляются</td>
                    </tr>
                    <tr>
                        <td>Мост (Bridge)&nbsp;</td>
                        <td>Решает проблему сложности путем разделения одного или нескольких классов на отдельные иерархии — <em>абстракцию</em> и <em>реализацию</em>.&nbsp;</td>
                    </tr>
                    <tr>
                        <td>Компоновщик (Composite)</td>
                        <td>Шаблон проектирования, объединяющий объекты в древовидную структуру для представления иерархии от частного к целому. Компоновщик позволяет клиентам обращаться к отдельным объектам и к группам объектов одинаково.</td>
                    </tr>
                    <tr>
                        <td>Фабричный метод (Factory method)</td>
                        <td>Паттерн проектирования, который определяет общий интерфейс для создания объектов в суперклассе, позволяя подклассам изменять тип создаваемых объектов&nbsp;</td>
                    </tr>
                    <tr>
                        <td>Строитель (Builder)</td>
                        <td>
                            <p>Позволяет поэтапно создавать сложные объекты с помощью четко определенной последовательности действий. Строительство контролируется объектом-распорядителем (director), которому нужно знать только тип создаваемого объекта.</p>
                        </td>
                    </tr>
                    <tr>
                        <td>Адаптор (Adapter)</td>
                        <td>Позволяет объектам с несовместимыми интерфейсами работать вместе (подобно адаптору для электрических приборов)</td>
                    </tr>
                    
                </tbody>
            </table>
            </div>
  </body>
</html>
