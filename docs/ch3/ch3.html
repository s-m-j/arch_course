---
layout: default
---

<!DOCTYPE html>
<html>
  <head>
    <title>Шаблоны Объектно-Ориентированного проектирования</title>
  </head>
  <body>
    <h1>Шаблоны Объектно-Ориентированного проектирования</h1>
    <p>
      Объектно-ориентированные концепции (ОО) в разработке программного
      обеспечения применяются много десятилетий, но повторим основы этой
      концепции кратко. Основная идея - все что нас окружвает в реальном мире,
      можно абстрактно представить как объект, то есть, как сущность обладающую
      двумя основными характеристиками:
    </p>
    <ul>
      <li>Поведение</li>
      <li>Состояние</li>
    </ul>
    <p>
      Ручной фонарикимеет состояния "выключен" и "включен", и функции "включить"
      и "выключить" в качестве поведения. Объекты могут иметь множество
      состояний и вариантов поведения, иногда даже могут содержать в себе другие
      объекты.
    </p>
    <p>
      Объектно-ориентированный дизайн (OOD) призван обеспечить модульность,
      абстракцию, повторное использование кода, возможности подключения (plug
      and play) и простоту отладки. Для этого состав и поведение системы
      декомпозируются и абстрагируются до степени позволяющей эффективно
      работать с отдельными составляющими сложной системы.
    </p>
    <p></p>
    <h2>Ключевые элементы OOD</h2>
    <p>Выделяют четыре ключевых элемента OOD:</p>
    <ul>
      <li>
        <b>Абстракция:</b> сокрытие сложности и низкоуровневых деталей
        реализации внутренних компонентов.
      </li>
      <li>
        <b>Инкапсуляция:</b> закрытие внутренней структуры данных внешним
        ограниченным интерфейсом, защищающим данные от несанкционированного
        использования
      </li>
      <li>
        <b>Модульность: </b> декомпозиция и выделение модулей для уменьшения
        сложности общей программы/функции. </li>
      <li><b>Иерархичность: </b> разделение системы на связанные подсистемы которые также внутри могут быть разделены на подсистемы, что позволяет работать с наименее сложными атомарными подсистемами.</li>
      </li>
    </ul>
    <p>Иногда выделяют также дополнительные элементы OOD:</p>
    <ul>
      <li><b>Типизация: </b>категоризация множеств элементов. Класс (в объектно-ориентированном программировании) - это отдельный тип. У него есть два подтипа, строгая  (strong) и слабая (weak) типизация</li>
      <li><p>Конкуренция: </p>Операционная система позволяет выполнять несколько задач или процессов одновременно, нужны средства моделирования этого поведения</li>
      <li><p>Персистентность</p>Классы и объекты могут занимать место в памяти и могут быть сериализованы для длительного хранения.</li>
    </ul>
    <h1>Принципы Объектного Дизайна</h1>
    <p>Начнем с набора принципов, известных по акрониму SOLID</p>
    <h2>Принцип единой ответственности (SRP) – <u>S</u>OLID</h2>
    <p>В объектно-ориентированном стиле единая ответственность подразумевает, что каждый класс должен
      иметь одну и только одну ответственность, и поэтому, если в класс необходимо внести изменения, для этого должны бать одна и только одна причина.</p>
    <p>Но эта формулировка не является удачной, она может приводить к совершенно ненужной атомарной декомпозийии. В своей книге Чистая Ахитектура Роберм Мартин предложил формулировку
      "Модуль должен отвечать за одного и только за одного актора" где под актором понимается заинтересованное лицо, или группа заинтересованных лиц, желающая изменения модуля. под
      модулем здесь понимается любая композиция из данных и функций над ними. Если модуль обслуживает только одного актора он не вызовет конфликтов при необходимости изменения, 
      в этом и есть назначение принципа единой ответственности
    </p>
    <p></p> 
    <h2>Принцип открытости/закрытости – S<u>O</u>LID</h2> 
    <p>Программные сущности должны быть открыты для расширения и закрыты для изменения. Иными словами, должна иметься возможность расширять поведение программных сущностей без их изменения </p>
    <p>Для реализации этого принципа в практике ООП следует придерживаться однонаправленной зависимости в иерархии классов (или подсистем). Изменения нижележащих сущностей не должны влиять на 
      вышестоящие, изменения вышестоящих влияют на нижележащие</p>
    <h2>Принцип подстановки Барбары Лисков – SO<u>L</u>ID</h2> 
    <p>Функции, которые используют базовый тип, должны иметь возможность использовать подтипы базового типа, не зная об этом. То есть, поведение наследуемых классов не должно противоречить поведению базовых классов.</p> 
    <h2>Принцип разделения интерфейсов – SOL<u>I</u>D</h2>
    <p>Клиенты не должны зависеть от методов, которые они не используют. Принцип разделения интерфейсов говорит о том, что слишком «толстые» интерфейсы необходимо разделять на более маленькие и специфические, 
      чтобы клиенты маленьких интерфейсов знали только о методах, которые необходимы им в работе.</p>
    <h2></h2>
    <p> Принцип инверсии зависимости (Dependency Inversion Principle; DIP) ут
      верждает, что наиболее гибкими получаются системы, в которых зависимости 
      в исходном коде направлены на абстракции, а не на конкретные реализации. </p>
    <p>Формулировка:</p>
    <ul>
      <li>Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций.</li>
      <li>Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.</li>
    </ul>
    <h2>Другие часто упоминаемые принципы ОО Дизайна </h2>
    <ul>
      <li><a href="https://habr.com/ru/articles/92570/">GRASP</a> (General Responsibility Assignment Software Patterns) — шаблоны проектирования, используемые для решения общих задач по назначению обязанностей классам и объектам</li>
      <li><a href="https://ru.wikipedia.org/wiki/Don%E2%80%99t_repeat_yourself">Don't repeat yourself (DRY)</a></li>
      <li><a href="https://logachev.pro/programmirovanie/slap/">Принцип единого уровня абстракций (SLAP)</a></li>
    </ul>
    <h1>Паттырны объектно-ориентированного проектирования</h1>
    <p>Паттерн проектирования — это часто встречающееся решение определённой проблемы при проектировании архитектуры программ.</p>
    <p>В отличие от готовых функций или библиотек, паттерн нельзя просто взять и скопировать в программу. Паттерн представляет собой не какой-то конкретный код, а общую концепцию решения той или иной проблемы, которую нужно будет ещё подстроить под нужды вашей программы.</p>
    <p>Паттерны часто путают с алгоритмами, ведь оба понятия описывают типовые решения каких-то известных проблем. Но если алгоритм — это чёткий набор действий, то паттерн — это высокоуровневое описание решения, реализация которого может отличаться в двух разных программах.</p>
    <p>Вы можете вполне успешно работать, не зная ни одного паттерна. Более того, вы могли уже не раз реализовать какой-то из паттернов, даже не подозревая об этом.
      Но осознанное владение инструментом как раз и отличает профессионала. Итак, зачем же знать паттерны?</p>
    <ul>
      <li><b>Проверенные решения: </b>Вы тратите меньше времени, используя готовые решения, вместо повторного изобретения велосипеда. До некоторых решений вы смогли бы додуматься и сами, но многие могут быть для вас открытием.</li>
      <li><b>Стандартизация кода: </b>Вы делаете меньше просчётов при проектировании, используя типовые унифицированные решения, так как все скрытые проблемы в них уже давно найдены.</li>
      <li><b>Общий программистский словарь: </b>Вы произносите название паттерна, вместо того, чтобы час объяснять другим программистам, какой крутой дизайн вы придумали и какие классы для этого нужны.</li>
    </ul>  
    <div class="table_component" role="region" tabindex="0">
      <table>
          <caption>
              <p><b>Пространство паттернов проектирования</b></p>
          </caption>
          <thead>
              <tr>
                  <th><br></th>
                  <th>
                      <p>Порождающие паттерны</p>
                  </th>
                  <th>
                      <p>Структурные паттерны</p>
                  </th>
                  <th>
                      <p>Паттерны поведения</p>
                  </th>
              </tr>
          </thead>
          <tbody>
              <tr>
                  <td>Класс</td>
                  <td>
                      <p>Фабричный метод</p>
                  </td>
                  <td>Адаптер</td>
                  <td>
                      <p>Шаблонный метод</p>
                      <p>Интерпретатор</p>
                  </td>
              </tr>
              <tr>
                  <td>Объект</td>
                  <td>
                      <p>Абстрактная фабрика</p>
                      <p>Одиночка</p>
                      <p>Прототип</p>
                      <p>Строитель</p>
                  </td>
                  <td>
                      <p>Адаптер</p>
                      <p>Декоратор</p>
                      <p>Прокси</p>
                      <p>Компоновщик</p>
                      <p>Мост</p>
                      <p>Фасад</p>
                      <p>Приспособленец</p>
                  </td>
                  <td>
                      <p>Итератор</p>
                      <p>Команда</p>
                      <p>Наблюдатель</p>
                      <p>Посетитель</p>
                      <p>Посредник</p>
                      <p>Состояние</p>
                      <p>Стратегия</p>
                      <p>Хранитель</p>
                      <p>Цепочка обязанностей</p>
                  </td>
              </tr>
          </tbody>
      </table>
      </div>  
  </body>
</html>
